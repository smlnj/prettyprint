prettyprint/device/device-notes.txt

#PrettyPrint

This is a new library to support writing pretty printers. The design of the library is
based on ideas from the Wadler-Lein Haskell package and the PPML pretty printer
meta language used in the Centaur system designed at INRIA Sophia in the 1980s.
It is purely-functional (strict). The user interface (structure Formatting) is designed
for utility rather than minimality.  Prettyprinting is done in two phases: (1)
construction of a *format* data structure, and (2) rendering a format to an output
medium (i.e., a display or printer).  It is also possible to translate a format to
another formatting language like HTML.

## Files

Formats
- 

- device/device.sig  (-> DEVICE)
- device/plain-device.sml  (-> Plain_Device)
- device/ansiterm-device.sml (-> ANSITerm_Device : DEVICE)


## The general model

A device is a character output device, where the character set is assumed to be fixed
width. A device may support various modes of text highlighting, like colors, bold, etc.,
which is supported by a device "style" feature.

It might also be capable of rendering things like Unicode codes to corresponding glyphs
(graphical characters), which allows it to support device "tokens".

A renderer is based on a given device (passed as a functor parameter). The renderer uses
an output stream, a line width that it gets from the device. The device can also provide a
device style type and device token type that can used to define stylemap and tokenmap
functions used to interpret logical styles and tokens that can be included in a format.


## The ANSI terminal device

The main idea is that a logical style will map to a device or "physical" style for an ANSI
terminal (ANSITerm_Device.style). "Applying" a style to a terminal outstream causes
corresponding attributes of the terminal device to be set, producing a new device state.
This new state is recorded internally on a device state stack.

There is an internal stack of device states (stateStack) that allows us to keep track
of the nesting of styles, corresponding to the fact that STYLE formats can be nested.

## Cancelling text highlighting modes using a Normal text attribute.

We don't include a NORMAL font attribute in our model. What would it mean, and how
might it be used?
 
Currently there is no way to specify "normal" or "regular" font through an ANSI terminal
mode (physical style). We could add a "Normal" attribute that would specify normal font,
which could in effect "cancel" BoldFace, Dim, Underlined, and Blink attributes. The Normal
attribute would conflict with any of the other _font_ attributes (Bold, Dim, Underlined,
Blinking) and would be set by default. A device style value (terminal attribute list)
should not contain both Normal and any of Bold, Dim, Underlined, Blinking. Adding the
BoldFace attribute would then involve removing/replacing the Normal attribute, and vice
versa, adding Normal would require removing BoldFace, Dim, Underlined, and Blinking, if
any of those are present in a style (attibute list).

Alternatively one could treat Normal as also orthogonal to Dim, Underlined, and Blinking
so that Normal + {Dim | Underlined | Blinking} was possible.

## Is an outstream an ANSI terminal?

Asking if outstream is a TTY does not do much good, since even knowing that we can't query
whether an outstream is an ANSI terminal.  We must just assume that any ANSI terminal
device has an outstream associated with an ANSI terminal (or emulation).


- The terminal model

  The relevant part of the terminal state, relating to "text highlighting" of various
  kinds, is captured in a type called termState, which is a record containing a
  description of various features, like foreground color, bold face, dim, etc.

- The device (physical) style model

  A device style is a list of attributes to be set when converting to a style.
  Styles are applied in a specified "scope", which is the "body" format of a
  format of the form STYLE (style, format).
  Styles can be nested and hence can "cascade" when successively applied.
  The (device) style type is defined in the device structure for a particular
  device class (like ANSI terminals).

- The device (physical) token model.

  The motivation for the device token type is to provide a target for translating
  logical tokens into displayable form.  For instance, a logical token might be the
  lower-case Greek lambda character, while the corresponding 
